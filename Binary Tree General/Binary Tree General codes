1. Maximum Depth of Binary Tree (https://leetcode.com/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-interview-150)


Solution: 

//DFS approach

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        
        int maxLeft = maxDepth(root->left);
        int maxRight = maxDepth(root->right);

        return max(maxLeft, maxRight) + 1;
    }
};

// BFS approach

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;

        queue<TreeNode*>que;
        que.push(root);

        int depth=0;

        while(!que.empty()){
            depth++;
            int n = que.size();
            while(n--){
                TreeNode* temp = que.front();
                que.pop();

                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
        return depth;
    }
};

Bonus Question (ABOVE FOLLOW QUESTION)

Minimum Depth of Binary Tree(https://leetcode.com/problems/minimum-depth-of-binary-tree/)

Solution: 

//DFS approach

class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;

        int L = minDepth(root->left);
        int R = minDepth(root->right);

        return (root->left and root->right) ? 1+min(L,R) : 1+max(L,R);
    }
};

//BFS approach

class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;

        queue<TreeNode*>que;
        que.push(root);

        int depth=0;

        while(!que.empty()){
            depth++;
            int n = que.size();
            while(n--){
                TreeNode* temp = que.front();
                que.pop();

                if(!temp->left and !temp->right) return depth;

                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
        return depth;
    }
};

2. Same Tree (https://leetcode.com/problems/same-tree/?envType=study-plan-v2&envId=top-interview-150)


Solution: 

class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p and !q) return true;

        if(!p || !q) return false;

        if(p->val != q->val) 
        return false;
        
        bool isSameLeft = isSameTree(p->left, q->left);
        bool isSameRight = isSameTree(p->right, q->right);

        return isSameLeft and isSameRight;
    }
};


3. Invert Binary Tree (https://leetcode.com/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-interview-150)

Solution: 

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;

        invertTree(root->left);
        invertTree(root->right);

        TreeNode* temp = root->left;
        root->left=root->right;
        root->right=temp;

        return root;
    }
};



4.  Symmetric Tree(https://leetcode.com/problems/symmetric-tree/?envType=study-plan-v2&envId=top-interview-150)

Solution: 

class Solution {
public:

    bool isMirror(TreeNode* root1, TreeNode* root2){
        if(!root1 and !root2) return 1;
        if(root1 and root2 and root1->val == root2->val) return (isMirror(root1->left, root2->right) and isMirror(root1->right, root2->left));
    
    return 0;
    }

    bool isSymmetric(TreeNode* root) {
        return isMirror(root, root);
    }
};

