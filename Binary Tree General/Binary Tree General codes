1. Maximum Depth of Binary Tree (https://leetcode.com/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-interview-150)


Solution: 

//DFS approach

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        
        int maxLeft = maxDepth(root->left);
        int maxRight = maxDepth(root->right);

        return max(maxLeft, maxRight) + 1;
    }
};

// BFS approach

class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;

        queue<TreeNode*>que;
        que.push(root);

        int depth=0;

        while(!que.empty()){
            depth++;
            int n = que.size();
            while(n--){
                TreeNode* temp = que.front();
                que.pop();

                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
        return depth;
    }
};

Bonus Question (ABOVE FOLLOW QUESTION)

Minimum Depth of Binary Tree(https://leetcode.com/problems/minimum-depth-of-binary-tree/)

Solution: 

//DFS approach

class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;

        int L = minDepth(root->left);
        int R = minDepth(root->right);

        return (root->left and root->right) ? 1+min(L,R) : 1+max(L,R);
    }
};

//BFS approach

class Solution {
public:
    int minDepth(TreeNode* root) {
        if(!root) return 0;

        queue<TreeNode*>que;
        que.push(root);

        int depth=0;

        while(!que.empty()){
            depth++;
            int n = que.size();
            while(n--){
                TreeNode* temp = que.front();
                que.pop();

                if(!temp->left and !temp->right) return depth;

                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
        return depth;
    }
};

2. Same Tree (https://leetcode.com/problems/same-tree/?envType=study-plan-v2&envId=top-interview-150)


Solution: 

class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p and !q) return true;

        if(!p || !q) return false;

        if(p->val != q->val) 
        return false;
        
        bool isSameLeft = isSameTree(p->left, q->left);
        bool isSameRight = isSameTree(p->right, q->right);

        return isSameLeft and isSameRight;
    }
};


3. Invert Binary Tree (https://leetcode.com/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-interview-150)

Solution: 

//DFS approach

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;

        invertTree(root->left);
        invertTree(root->right);

        TreeNode* temp = root->left;
        root->left=root->right;
        root->right=temp;

        return root;
    }
};

// BFS approach

Solution: 

class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;

        queue<TreeNode*>q;
        q.push(root);

        while(!q.empty()){
            int n = q.size();
            while(n--){
                TreeNode* temp = q.front();
                q.pop();

                TreeNode* node = temp->right;
                temp->right = temp->left;
                temp->left = node;

                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);
            }
        }
        return root;
    }
};


4.  Symmetric Tree(https://leetcode.com/problems/symmetric-tree/?envType=study-plan-v2&envId=top-interview-150)

Solution: 

class Solution {
public:

    bool isMirror(TreeNode* root1, TreeNode* root2){
        if(!root1 and !root2) return 1;
        if(root1 and root2 and root1->val == root2->val) return (isMirror(root1->left, root2->right) and isMirror(root1->right, root2->left));
    
    return 0;
    }

    bool isSymmetric(TreeNode* root) {
        return isMirror(root, root);
    }
};


5. Construct Binary Tree from Preorder and Inorder Traversal (https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-interview-150)

Solution: 

class Solution {
public:

    TreeNode* solve(vector<int>&inorder, vector<int>&preorder, int start, int end, int &preIdx, map<int,int>&mp) {
        if(start > end) return NULL;

        TreeNode* root = new TreeNode(preorder[preIdx++]);
        int i = mp[root->val];

        root->left = solve(inorder, preorder, start, i-1, preIdx, mp);
        root->right = solve(inorder, preorder, i+1, end, preIdx, mp);
        
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = inorder.size();
        int preIdx = 0;
        map<int,int>mp;
        for(int i=0;i<inorder.size(); i++){
            mp[inorder[i]] = i;
        }
        return solve(inorder, preorder, 0, n-1, preIdx, mp);
    }
};


6. Construct Binary Tree from Inorder and Postorder Traversal (https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&envId=top-interview-150)

(Ismai "root->right" pahale aya hai "root->left" se, solution mai because postorder mai root last mai aata hai aur root ke baad jo bhi aata node wo inorder mai right mai hai , so that's why first right then left recursive call)


Solution: 

class Solution {
public:

    TreeNode* solve(vector<int>&inorder, vector<int>&postorder, int start, int end, int &postIdx) {
        if(start > end) return NULL;

        TreeNode* root = new TreeNode(postorder[postIdx]);
        int i = start;
        while(inorder[i]!=postorder[postIdx]) i++;

        postIdx--;
        root->right = solve(inorder, postorder, i+1, end, postIdx);
        root->left = solve(inorder, postorder, start, i-1, postIdx);

        return root;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n = inorder.size();
        int postIdx = n-1;

        return solve(inorder, postorder, 0, n-1, postIdx);
    }
};



7. Populating Next Right Pointers in Each Node II


Solution: 

class Solution {
public:
    Node* connect(Node* root) {
        if(!root) return root;
        queue<Node*>q;
        q.push(root);

        while(!q.empty()){
            int n = q.size();
            while(n--){
                Node* node = q.front();
                q.pop();
                if(n==0) node->next = NULL;
                else node->next = q.front();

                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        }
        return root;
    }
};



9.  Path Sum (https://leetcode.com/problems/path-sum/?envType=study-plan-v2&envId=top-interview-150)


Solution: 


class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return 0;

        if(root->val == targetSum and !root->left and !root->right) return 1;

        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);
    }
};


10. Sum Root to Leaf Numbers (https://leetcode.com/problems/sum-root-to-leaf-numbers/?envType=study-plan-v2&envId=top-interview-150)

Input: root = [4,9,0,5,1]
Output: 1026

Solution: 

class Solution {
public:

    int solve(TreeNode* root, int curr){
        if(!root) return 0;

        curr = (curr*10) + root->val;

        if(!root->left and !root->right) return curr;

        return solve(root->left, curr) + solve(root->right, curr);
    }

    int sumNumbers(TreeNode* root) {
        return solve(root, 0);
    }
};



13. Count Complete Tree Nodes (https://leetcode.com/problems/count-complete-tree-nodes/?envType=study-plan-v2&envId=top-interview-150)

(NOTE: Design an algorithm that runs in less than O(n) time complexity.)

Solution: 


class Solution {
public:
    int countNodes(TreeNode* root) {
        if(!root) return 0;

        int lh = findLeftHeight(root);
        int rh = findRightHeight(root);

        if(lh == rh) return (1<<lh)-1;

        return 1 + countNodes(root->left) + countNodes(root->right);
    }

    int findLeftHeight(TreeNode* root){
        if(!root) return 0;
        TreeNode* temp = root;

        int cnt = 0;
        while(temp){
            temp = temp->left;
            cnt++;
        }
        return cnt;
    }

    int findRightHeight(TreeNode* root){
        if(!root) return 0;
        TreeNode* temp = root;

        int cnt = 0;
        while(temp){
            temp = temp->right;
            cnt++;
        }
        return cnt;
    }
};


16. Average of Levels in Binary Tree (https://leetcode.com/problems/average-of-levels-in-binary-tree/?envType=study-plan-v2&envId=top-interview-150)

Solution: 


class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*>q;
        q.push(root);

        vector<double>res;
        while(!q.empty()){
            int n = q.size();
            
            double sum = 0;
            int cnt = 0;
            while(n--){
                TreeNode* temp = q.front();
                q.pop();

                sum+= temp->val;
                cnt++;

                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);
            }
            res.emplace_back(sum/cnt);
        }
        return res;
    }
};


17. Binary Tree Level Order Traversal (https://leetcode.com/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&envId=top-interview-150)

Solution: 


class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(!root) return {};
        queue<TreeNode*> q;
        q.push(root);
        vector<vector<int>>res;
        while(!q.empty()){
            int n = q.size();
            vector<int>v;
            while(n--){
                TreeNode* temp = q.front();
                q.pop();
                v.emplace_back(temp->val);

                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);
            }
            res.emplace_back(v);
        }
        return res;
    }
};





